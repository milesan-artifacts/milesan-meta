# Copyright 2024 Tobias Kovats, Flavien Solt, ETH Zurich.
# Licensed under the General Public License, Version 3.0, see LICENSE for details.
# SPDX-License-Identifier: GPL-3.0-only

# This module generates ELF files from a program generated by Cascade.

from params.runparams import DO_ASSERT, PATH_TO_TMP, PICKLE_FUZZERSTATE
from params.fuzzparams import USE_MMU, USE_COMPRESSED, FILL_MEM_WITH_DEAD_CODE
from common.bytestoelf import gen_elf
from common.spike import SPIKE_STARTADDR
from milesan.finalblock import finalblock_spike_resolution
from milesan.randomize.pickinstrtype import gen_next_instrstr_from_isaclass
from milesan.cfinstructionclasses import SpeculativeInstructionEncapsulator
from collections import defaultdict
from copy import copy
import os
import pickle

if USE_COMPRESSED:
    from rv.rv32ic import rv32ic_addi
    NOP_PADDING = rv32ic_addi(0, 0) << 16
# From a fuzzerstate, generates an ELF, may it be for spike resolution or for RTL simulation
# Also integrates the final block.
# @param instr_objs an iterable (one per basic block) of iterables of CFInstructions or placeholders
# @param test_identifier typically the random seed, mem size, design name, max number of bbs
# @return the generated elf path
def gen_elf_from_bbs(fuzzerstate, is_spike_resolution, prefixname: str, test_identifier: str, start_addr: int):
    if DO_ASSERT:
        assert len(fuzzerstate.instr_objs_seq) == len(fuzzerstate.bb_start_addr_seq)


    # Create the bytecode for the ELF file
    addr_instrs = defaultdict(bytes) # addr_instrs[addr] = single byte
    for bb_start_addr, bb_instrs in zip(fuzzerstate.bb_start_addr_seq, fuzzerstate.instr_objs_seq):
        for instr_id_in_bb, instr_obj in enumerate(bb_instrs):
            if instr_obj.iscompressed:
                assert USE_COMPRESSED
                #if instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution) == 0x0590006f: print(f"inst after j is {fuzzerstate.instr_objs_seq[bb_id+1]}") #which bytecode {hex(fuzzerstate.instr_objs_seq[bb_id+1][0].gen_bytecode_int(is_spike_resolution=is_spike_resolution))}")
                # instr_bytecode_int = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution)
                # curr_bytecode = (NOP_PADDING | instr_bytecode_int&0xFFFF).to_bytes(4, 'little')
                curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(2, 'little')
            else:
                curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
            for curr_byte_id, curr_byte in enumerate(curr_bytecode):
                # curr_addr_bk = bb_start_addr + 4*instr_id_in_bb + curr_byte_id # NO_COMPRESSED
                if instr_obj.iscompressed:
                    assert curr_byte_id < 2
                curr_addr = bb_start_addr + sum([int(not i.iscompressed)*2+2 for i in bb_instrs[:instr_id_in_bb]]) + curr_byte_id
                # assert curr_addr == curr_addr_bk, f"Failed at {instr_obj.get_str()}: {hex(curr_addr)} != {hex(curr_addr_bk)}"
                if DO_ASSERT:
                    assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
                addr_instrs[curr_addr] = curr_byte


    for instr_id_in_bb, instr_obj in enumerate(fuzzerstate.ctxsv_bb):
        if instr_obj is None:
            raise ValueError(f"instrobj is None for ctxsv_bb at index {instr_id_in_bb}")
        curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr =  fuzzerstate.ctxsv_bb_base_addr + 4*instr_id_in_bb + curr_byte_id # NO_COMPRESSED
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Add the initial register values
    for reg_data_id, reg_data_doubleword in enumerate(fuzzerstate.initial_reg_data_content):
        curr_bytecode = reg_data_doubleword.to_bytes(8, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.initial_reg_data_addr + 8*reg_data_id + curr_byte_id # doublewords therefore 8
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Add the final basic block
    if is_spike_resolution:
        final_block = finalblock_spike_resolution(fuzzerstate)
    else:
        final_block = fuzzerstate.final_bb

    for instr_id_in_bb, instr_obj in enumerate(final_block):
        curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
        for curr_byte_id, curr_byte in enumerate(curr_bytecode):
            curr_addr = fuzzerstate.final_bb_base_addr + 4*instr_id_in_bb + curr_byte_id # NO_COMPRESSED
            if DO_ASSERT:
                assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
            addr_instrs[curr_addr] = curr_byte

    # Write the random data blocks.
    for random_block_id, random_block_content4by4bytes in enumerate(fuzzerstate.random_block_contents4by4bytes):
        # Add the random data block
        for word_id, word_content in enumerate(random_block_content4by4bytes):
            curr_bytecode = word_content.to_bytes(4, 'little')
            for curr_byte_id, curr_byte in enumerate(curr_bytecode):
                curr_addr = fuzzerstate.random_data_block_ranges[random_block_id][0] + 4*word_id + curr_byte_id # NO_COMPRESSED
                if DO_ASSERT:
                    assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
                addr_instrs[curr_addr] = curr_byte


    # Generate the PT initial values, FIXME maybe optimize that
    if USE_MMU:
        pte_content = fuzzerstate.pagetablestate.all_pt_entries
        # Iterate throught the layouts
        for va_layout, curr_layout_ptes in zip(fuzzerstate.pagetablestate.ptr_pt_base_list_per_layout, pte_content):
            # For each layout, got through all levels
            for level, pte_list in enumerate(curr_layout_ptes):
                curr_pt_base = va_layout[level]
                # For each level, got through each entries
                for pte_id, pte in enumerate(pte_list):
                    curr_bytecode = pte.to_bytes(fuzzerstate.ptesize, 'little')
                    for curr_byte_id, curr_byte in enumerate(curr_bytecode):
                        curr_addr = curr_pt_base + fuzzerstate.ptesize*pte_id + curr_byte_id - SPIKE_STARTADDR # NO_COMPRESSED
                        if DO_ASSERT:
                            assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {hex(curr_addr)}"
                            assert curr_addr <= fuzzerstate.memsize, f"address to large: {hex(curr_addr)}, max is {hex(fuzzerstate.memsize)}"
                        addr_instrs[curr_addr] = curr_byte

    if not is_spike_resolution:
        for instr_obj in fuzzerstate.spec_instr_objs_seq:
            # instr_obj.print()
            if instr_obj.iscompressed:
                assert USE_COMPRESSED # Do we care if the instructions need to match the spec?
                curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(2, 'little')
            else:
                curr_bytecode = instr_obj.gen_bytecode_int(is_spike_resolution=is_spike_resolution).to_bytes(4, 'little')
            for curr_byte_id, curr_byte in enumerate(curr_bytecode):
                if instr_obj.iscompressed:
                    assert curr_byte_id < 2
                curr_addr = instr_obj.paddr + curr_byte_id - SPIKE_STARTADDR
                if DO_ASSERT:
                    assert curr_addr not in addr_instrs, f"Trying to write twice to the same address: {instr_obj.get_str()}"
                addr_instrs[curr_addr] = curr_byte
        

    # Generate a bytes object
    curr_bytearray = bytearray(fuzzerstate.memsize) # Zero-filled
    for curr_addr, curr_byte in addr_instrs.items():
        curr_bytearray[curr_addr] = curr_byte
    curr_bytes = bytes(curr_bytearray)


    fuzzerstate.gen_tmp_dir()
    elfpath = os.path.join(fuzzerstate.tmp_dir, f"{prefixname}{test_identifier}.elf")

    # Generate the ELF object
    gen_elf(curr_bytes, start_addr=fuzzerstate.bb_start_addr_seq[0], section_addr=start_addr, destination_path=elfpath, is_64bit=fuzzerstate.is_design_64bit)
    
    if PICKLE_FUZZERSTATE:
        fuzzerstate.rtl_elfpath = elfpath
        fuzzerstate.pickle(prefixname,test_identifier)

    return elfpath
